

# 第5章 数据结构II——结构体与联合体

 

[toc]

 

## 5.1 结构体

 

### 5.1.1 结构体类型的声明

 

- 结构体类型声明语句必须以分号结尾，可以放在函数内部， 也可以放在函数外部，其作用域和变量的作用域类似

- 不同于变量可以使用extern 声明，必须先声明结构体类型，再定义其变量，如在a.c文件中定义了`struct Student `结构体之后，在b.c文件中 `extern struct Student `的提取声明将被忽略，也就是不接受结构体类型的提取声明.因为此时b.c文件只知道结构体变量的性质，并不知道其定义。简单的办法就是把结构体定义放在公共头文件中，a.c和b.c都包含该头文件。

 

### 5.1.2 结构体变量的定义

 

```c

struct Student st;//传统C语言方式

Student st;//C++方式

```

 

注：从语法角度出发，结构体变虽可以和结构体成员同名，因为它们处于不同的＂层次“

上，不会有二义性，但从软件工程角度出发建议不要这样做。

 

### 5.1.3 结构体变量的引用

 

- 引用结构体变量中的一个成员

 

  ```c

  结构体变量．成员名     // "."为结构体变量成员访问运算符

  结构体指针变量->成员名// "->"为结构体指针变量成员访问运算符

  ```

 

- 结构体类型变量的整体引用

 

  - 用户可以将一个结构体变量作为一个整体赋给另一个同结构体类型的结构体变量，其前提条件是两个结构体变量必须具有完全相同的结构体类型。

 

  - 当结构体内成员有指针变量类型时，单纯的整体幅值会造成“浅复制”，即a结构体变量幅值给b结构体变量后，b的指针变量成员同样指向了a结构体的对应成员指向的位置。因此以后对b的该成员的操作可能会直接影响到a结构体变量。

 

### 5.1.4 结构体变量的初始化

 

​    在对结构体变量赋初值时， C 编译程序按每个成员在结构体中的顺序一一对应赋初值，不允许跳过前面的成员给后面的成员赋初值；但可以只给前面的若干个成员赋初值，对于后面未赋初值的成员，对于数值型和字符型数据，系统自动赋初值零。

 

### 5.1.5 结构体变量的内存分配

 

- 结构体的内存对齐

 

  - **结构体变量的首地址是结构体中有效对齐值的整数倍**

 

    编译器在给结构体开辟空间时，首先找到结构体中**有效对齐值**。有效对齐值取得方法：

 

    1. 取结构体内所有成员数据类型中占字节空间**最大**的**自身对齐值**记为N1.【注：若有结构体类型成员，其对齐值为**该结构体成员内的所有成员中自身对齐值最大的那个值**。】

    2. 寻找是否有**自定义有效对齐值**，若有则记为N2.【注1：**自定义有效对齐值**是用宏命令#pragma pack(n) 自定义的，对齐值为n ，用宏命令#pragma pack() 取消自定义对齐。】【注2：自定义有效对齐值中n=1时，称为**紧凑编译**】

    3. 若N2不存在，则**有效对齐值**就是N1；若N2存在，则**有效对齐值**便是：min｛N1,N2｝。

 

    然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。

 

  - **结构体每个成员相对于结构体首地址的偏移量（offset）都是当前成员大小的整数倍，如有需要编译器会在成员之间加上填充字节**

 

    为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。

 

  - **结构体的总大小为结构体中最宽基本数据成员的整数倍。如有需要，编译器将会在结构体末尾**（[存疑](https://blog.csdn.net/Thanksgining/article/details/42024977)）**添加填充字符**

 

- 柔性数组成员

 

  ```c

  Struct Type

  {

     int n;

     int a[];//或者 “int a[0];”

  }s;

  ```

 

  成员数组a 称为柔性数组，它的长度为0 , 所以sizeof(s) 的大小为4, 以后可以分配变长度空间。柔性数组只能作为最后一个成员。[柔性数组扩展阅读](http://luodw.cc/2015/10/22/Cplus6/)

 

 

 

## 5.2 联合体

 

### 5.2.1 定义联合体的注意事项

 

- 分配内存时，联合体变量所占内存的实际长度等千各成员中占内存最长的成员的

  长度。

- 只有最后一个存放的成员值有效，其他成员将失去原值。

 

### 5.2.2 初始化联合体的注意事项

 

- 联合体变量在定义的同时只能用第1个成员的类型的值进行初始化，对联合体变量初始化时尽管只能给第1个成员赋值，但必须用大括号括起来。

- 联合体变量和结构体变量的区别：

  - 联合体变量在定义的同时只能用第1个成员的类型的值进行初始化

  - 联合体变量中的所有成员共享一段公共存储区，所以联合体变量所占内存的字节数与其成员中占字节数最多的那个成员相等；而结构体变量中的每个成员分别占有独立的内存空间，所以结构体变量所占内存的字节数是其成员所占字节数的总和

  - 由于联合体变量中的所有成员共享内存空间，因此变量中的所有成员的首地址相同，而且变量的地址也就是该变量成员的地址

- 字节序描述数据在内存中的排列格式。在存储和加载时， CPU 必须采用硬件支待的字节序格式。字节序分为两类，即**大端( BigEndian ) **和**小端(LittleEndian ) **

  采用大端格式时，高位字节存储在第一个位置，次高位字节存储在次邻位置。采用小端格式时，低位字节存储在第一个位置，次低位字节存储在次邻位置。

  - [字节序扩展阅读1](https://zhuanlan.zhihu.com/p/44625744)

  - [字节序扩展阅读2](https://songlee24.github.io/2015/05/02/endianess/)

 

## 5.3 枚举类型

 

暂无

 

## 5.4 用户定义类型

 

### 5.4.1 有关typedef的说明

 

- 使用typedef 只能对已有的类型名重新命名，并不能产生新的数据类型，原有的类型也没有被取代，即用户定义类型只是原类型的一个别名

 

- typedef 并不是做简单的字符串替换。**typedef与#define 的区别**:

 

  - **语法格式不同**：typedef定义是语句，句尾要加上分号；而#define不是语句，不能在句尾加分号

 

  - **用法不同**： typedef用来定义一种数据类型的别名，增强程序的可读性；而#define主要用来定义常量，以及书写复杂的使用频繁的宏

 

  - **执行时间不同**：typedef是编译过程的一部分，有类型检查的功能；#define 是宏定义，是预编译的部分，其发生在编译之前，只是简单粗暴地进行字符串的替换，不进行类型的检查

 

  - **作用域不同**：typedef有作用域限定；#define不受作用域约束，只要是在define命令后的引用都正确

 

  - **对指针的操作不同**： typedef 和#define 定义的指针有很大的区别，如此例：

 

    ```c

    typedef char * String_t;//是语句，为char＊指定一个新类型别名String_t, 有类型检查，编译的时候处理；

    #define String_d  char *//是宏命令，只做简单的替换，无类型检查，预编译的时候处理，所以typedef 比＃define安全

    //而且定义多个变量时有区别，如：

    String_t a,b; /*等同于*/ char *a,*b;

    String_d c,d; /*替换为*/ char *c,d;  //c为char＊类型，而d为char类型。

 

 

    ```

 

  - [typedef与#define区别的扩展阅读](https://www.runoob.com/note/24230)

 

- 用typedef 定义类型名可嵌套进行

 

- 用typedef 定义类型名有利于程序的移植，并增加程序的可读性.

 





