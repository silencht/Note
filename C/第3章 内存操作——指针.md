

# 第三章 内存操作——指针

 

[toc]

 

## 3.1 指针基础

### 3.1.1 指针变量与运算

指针变量中存放的是地址值，无论指针变量的基类型是何种数据类型，占用的内存大小都是相同的。

### 3.1.2 野指针

一个指针变量的值（地址值）为垃圾值的指针变量称为野指针。产生野指针的原因和解决方法：

- 指针变量定义时没有被初始化。解决办法是定义指针时初始化，可以是具体的地址值，也可以是NULL

- 指针p被free或者delete之后没有被置为NULL，后面还使用它。解决办法是指针指向的内存空间被释放后指针应该指向NULL

- 指针操作超越了所指变量的作用域。解决办法是在所指变量的作用域结束前释放掉变量的地址空间，并让指针指向NULL

 

## 3.2 常量和常量指针

### 3.2.1 常量

程序执行期间其值**不能被改变的量**称为**常量**，常量分为**字面常量**和**符号常量**

1. **字面常量**

字面常量只能引用不能修改，如123等，通常保存在程序符号表中，程序无法读取字面常量的地址，只有一个例外，即字符串常量。例如：`char *p="abc";`，字符串常量放在静态数据区，由p指针指向它，**不能通过p指针来修改该常量**。

 

 程序员最好采用`const char *p="abc";`定义，这样在执行`*p='x'`时会发生编译错误，以便避免bug。

 

 `int *p=123；`也是不允许的，尽管123是常量，但这里编译器认为是将123作为地址存放在指针变量p中，而123是整数，正确的做法是`int *p=（int *）123；`即将123转换为地址值赋给p，但这种做法是有危险的。

 

 又由于p指向的常量字符串不是通过malloc函数分配的，所以执行free（p）会导致程序崩溃。

1. **符号常量**

 符号常量主要又两种定义方法：

 - 第一种是用宏定义实现（即宏常量），例如`#define PI 3.14`

 - 第二种是用const定义（即const常量），const的意思是“一个不能被改变的变量”，例如`const int n=123；`

 - const修饰的常量的值不能修改，所以必须在定义时初始化

 

 两种定义方法的区别：

  - 前者是宏替换命令，不是语句，所以不以“；”结尾，后者是定义，以“；”结尾。

  - 前者在预处理时进行替换，后者定义的常量像变量一样（称为常变量），只是其值不能改变

  - const常量有数据类型，而宏常量没有数据类型。编译器对前者进行类型安全检查，对后者不进行类型安全检查。

 

### 3.2.2 const指针常量、常量指针

在定义指针时用const关键字进行修饰，称为const指针常量，有三种情况：

 

1.**常量指针**

 

用const修饰`*`时称为常量指针，表示**不能修改p指向的内容** [注意此时p指向的内容仅仅是不能通过指针p修改，其自身如果不是常量的话，可以通过其他方式修改]。例如：

 

`const char *p;`，此时不能通过p指针修改指向的内容，否则会出现编译错误。

- 也可以写作`char const *p;`，但习惯上常用第一种

- 它的本质还是一个指针，是一个指向常量的指针（变量）

- 指针本身的指向可以改变，但是指向的内容不可修改

- 通常用于**参数传递**过程中，如果被传入的参数的值在函数执行期间不希望被修改可以使用`const` 修饰已达到安全的目的。

 

2.**指针常量**

 

`char * const p；`const修饰p，**表示不能修改变量p**。指针p是一个指针常量，p的值不能再发生改变，所以必须初始化。一旦初始化，p不能指向其他数据，但可以通过指针p修改所指的内容。

- 一般指针常量用于不会发生指向变化的指针，但是用法并不常见。

 

3.**指向常量的常指针**

 

相当于常量指针和指针常量的结合，格式 `const char * const p = &num`,相当于有一个**指向不可修改的指针指向了一个不可修改的常量**，在实际coding中很少使用。

 

4.**总结**

- **const 修饰谁，谁就不变**

 

## 3.3 多级指针

### 3.3.1 `void *`和`void **`

- `void`：字面意思是**无类型**，真正发挥作用的地方在于对函数返回值的限定和对函数参数的限定；

- `void *`：**无类型指针**，可以指向任何类型的数据。

 - 既然是无类型指针，那么就不能做**解引用**与**指针算数运算**.

 - 任何类型的指针都可以直接幅值给它，无需进行强制类型转换，但这并不意味这`void *`也可以无须强制类型转换地赋给其他类型的指针。因为“无类型”可以包容“有类型”，但是“有类型”不能包容“无类型”，例如：

 

```c

void *p1;

int *p2;

double  *p3;

p3=p2;//错误，必须改为第5行，强制转换后才可编译通过

p3=(double *)p2;//正确

p1=p2;//正确，可以将任何有类型地址赋给无类型指针变量

p2=p1;//错误，不能将任何无类型地址赋给有类型指针变量

p2=(int *)p1;//正确，将无类型地址强制转换为有类型地址，这就是malloc等函数原型的返回值为void *的原因

 

```

- `void *`**的用处**：因为对于函数的通用型接口，你不知道用户的数据类型是什么，但是你必须能够处理用户的各种类型数据，因而会使用`void*`。`void*`能包容地接受各种类型的指针。也就是说，如果你期望接口能够接受任何类型的参数，你可以使用`void*`类型。但是在具体使用的时候，你必须转换为具体的指针类型。例如，你传入接口的是`int*`，那么你在使用的时候就应该按照`int*`使用。

 

- `void **`：本质上是标识一个二级指针,即**无类型指针的指针**，它指向一个放 `void*`型的地方.

 

 `(void**)&data`：把变量的地址强制转换为无类型指针的指针，即`(void**)`本质表示将`&data`强制转换类型为一个指向无类型的二级指针。举例：

 

```c

//为了使函数更加的通用，使用void**作为函数参数类型

void swap(void **a, void **b)

{

    void *t;

    t =*a;

    *a =*b;

    *b=t;

}

int main()

{

    int i = 3;

    int j = 5;

    int *p = &i;

    int *q = &j;

    char *s1="abc";

    char *s2="def";

    swap((void**)&p, (void**)&q);

    swap((void**)&s1, (void**)&s2);

}

//注意char*是字符串指针，需要改变其对应的变量必须用地址，s1就是"abc"的起始地址，是不能被改变，要想改变s1必须用他的地址也就是&s1，所以需要void**

————————————————

版权声明：本文为CSDN博主「unix21」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

[原文链接](https://blog.csdn.net/unix21/article/details/8923752)

```

 

`*(void**)&data`：data是指针变量，&data取指针变量的地址， `(void **)`将这个data这个指针变量的地址类型强制转换为 指向无类型的二级指针类型，最后“翻译”最前面的`*`，作用是解引用，将 `(void **)`类型的&data变量解引用一次，即指向了data本身，但此时data本身的数据类型实际上已经是无类型的一级指针了。

 

![](https://silencht.oss-cn-beijing.aliyuncs.com/img/b1388529-d6b4-4ed3-aa38-7ec0cf449bff.jpg)

 

## 3.4 实例解析

 

### 3.4.1 （int&)a

 

代码：

 

```c

float a = 01f;

printf("%d",(int&)a);

```

 

解释：（存疑）

 

​    等价于`*(int*)(&a)`，

 

1. 首先对float型变量取地址

2. 强制类型转换为整型变量的地址（地址的值并没有变）

3. 将该地址指向的变量输出（但是由于整型和浮点型数据存储方式的不同，输出结果是不同的）





