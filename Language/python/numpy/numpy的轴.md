#### Numpy的轴

##### 1、轴、维度及秩

###### 1、轴

   numpy数组中的轴不太容易理解，但是却非常重要。[官方定义](http://scipy.github.io/old-wiki/pages/Tentative_NumPy_Tutorial)为：轴即维度（In Numpy dimensions are called axes.）。
   对于二维数组，0轴即代表（沿着）数组的行，1轴代表（沿着）数组的列，对二维数组：

```python
arr1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> arr1
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

   其轴0、1如下图所示：

![numpy二维数组的轴](https://silencht.oss-cn-beijing.aliyuncs.com/img/numpy二维数组的轴.png)

<center>图1-1　　二维数组的轴示意图</center>

为了验证上述结论，我们通过代码对每个轴方向的数字进行求和计算，如下：

```python
>>> arr1.sum(axis=0)
array([12, 15, 18])
>>> arr1.sum(axis=1)
array([ 6, 15, 24])
```

对于三维数组，这个问题就有点复杂了。给定如下的三维数组：

```python
>>> arr = np.array([[[0, 1, 2, 3], [4, 5, 6, 7]], [[8, 9, 10, 11], [12, 13, 14, 15]]])
>>> arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
```

由轴的定义可知，数组**`arr`**有**3**条轴，编号分别为0、1、2，要直接看出来这三条轴分别对应什么方向有点困难。最好的办法就是先将三维数组降维成一个二维数组，这样就可以获得原数组的0轴、1轴。怎么降呢？把最内层数组作为一个整体来看待，即有：

```python
A = [0, 1, 2, 3]
B = [4, 5, 6, 7]
C = [ 8,  9, 10, 11]
D = [12, 13, 14, 15]
arr = [[A, B],
       [C, D]]
```

可以看出通过这种变换，我们就把原数组从形式上转化成了一个二维数组，但是一定要注意**这里的A、B、C、D均为一维数组，对它们进行操作时，要按照向量而非标量的运算法则进行。**降维后的轴方向如下图所示：

![降维后轴方向示意图](https://silencht.oss-cn-beijing.aliyuncs.com/img/降维后轴方向示意图.png)

<center>图1-2　　降维后轴方向示意图</center>

此时对0、1轴方向求和有：

```python
# arr.sum(axis=0) = [[A + C], [B + D]]
# [A + C] = [0+8, 1+9, 2+10, 3+11] = [8, 10, 12, 14]
# [B + D] = [4+12, 5+13, 6+14, 7+15] = [16, 18, 20, 22]
>>> arr.sum(axis=0)
array([[ 8, 10, 12, 14],
       [16, 18, 20, 22]])
# arr.sum(axis=1) = [[A + B], [C + D]]
>>> arr.sum(axis=1)
array([[ 4,  6,  8, 10],
       [20, 22, 24, 26]])
```

那么2轴方向呢？由于A、B、C、D均为一维数组，因此第三个轴（轴2）即为最内层数组的行方向，如下图所示：

![第三条轴即轴2](https://silencht.oss-cn-beijing.aliyuncs.com/img/第三条轴即轴2.png)

<center>图1-3　　轴2方向示意图</center>

所以对轴2方向进行求和，实际上就是分别将A、B、C、D的元素求和**（对一维向量应用sum函数，计算的是该向量所有元素之和）**，代码及结果如下：

```python
# sum(A) = [0 + 1 + 2 + 3] = [6]
>>> arr.sum(axis=2)
array([[ 6, 22],
       [38, 54]])
```

由此可知，**对于多维数组，numpy对轴的编号是先行后列，由外向内！**实际中三维数组算是维度比较高的了，至于四维及以上的不太常见，因此没必要讲，但是为了验证我们刚才提到的这个结论，我们再举一个四维数组来证明。

我们先生成一个4\*2\*2\*2数组，代码如下：

```python
>>> arr2 = np.arange(0, 32)
>>> arr2
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])
>>> arr2.reshape(4,2,2,2)
array([[[[ 0,  1],
         [ 2,  3]],

        [[ 4,  5],
         [ 6,  7]]],


       [[[ 8,  9],
         [10, 11]],

        [[12, 13],
         [14, 15]]],


       [[[16, 17],
         [18, 19]],

        [[20, 21],
         [22, 23]]],


       [[[24, 25],
         [26, 27]],

        [[28, 29],
         [30, 31]]]])
```

为了手算出结果，同样的，我们需要对原数组进行降维，降维方法是将内部的二维数组分别用字母表示，即有：

```python
A = [[ 0,  1], [ 2,  3]]
B = [[ 4,  5], [ 6,  7]]
C = [[ 8,  9],  [10, 11]]
D = [[12, 13],  [14, 15]]
E = [[16, 17],  [18, 19]]
F = [[20, 21],  [22, 23]]
G = [[24, 25], [26, 27]]
H = [[28, 29], [30, 31]]
arr2 = [[A, B], 
        [C, D],
        [E, F],
        [G, H]]
```

降维后可知，对0、1轴求和的结果为：

$arr.sum(axis=0)=[A+C+E+G , B+D+F+H]$

$arr.sum(axis=1)=[A+B ,  C+D ,  E+F ,  G+H]$

因为A~H均为二维数组，因此其求和受向量运算法则约束，即有：
$$
\begin{split} A + C + E + G &= \lbrack A_0 + C_0 + E_0 + G_0 \ , \ A_1 + C_1 + E_1 + G_1 \rbrack \\\\ &= \lbrack {\lbrack 0, 1 \rbrack + \lbrack 8, 9 \rbrack + \lbrack 16, 17 \rbrack + \lbrack 24, 25 \rbrack } \ , \ {\lbrack 2, 3 \rbrack + \lbrack 10, 11 \rbrack + \lbrack 18, 19 \rbrack + \lbrack 26, 27 \rbrack} \rbrack \\\\ &= \lbrack {\lbrack 0 + 8 + 16 + 24 \ , \ 1 + 9 + 17 + 25 \rbrack} \ , \ \\\\ &\ \ \ \ \ \ \  {\lbrack 2 + 10 + 18 + 26 \ , \ 3 + 11 + 19 + 27 \rbrack} \rbrack \\\\ &= \lbrack {\lbrack 48 \ , \ 52 \rbrack} \ , \  {\lbrack 56 \ , \ 60 \rbrack} \rbrack \\同理可求得：\\ \\ B + D + F + H &= \lbrack {\lbrack 64 \ , \ 68 \rbrack} \ , \  {\lbrack 72 \ , \ 76 \rbrack} \rbrack \end{split}
$$
这与代码运行的结果完全一致，如下图所示：

![四维数组0轴求和代码运行结果](https://silencht.oss-cn-beijing.aliyuncs.com/img/四维数组0轴求和代码运行结果.png)

<center>图1-4　　四维数组0轴求和代码运行结果</center>

 同理可求出1轴求和结果：

```python
>>> arr2.sum(axis=1)
array([[[ 4,  6],
        [ 8, 10]],

       [[20, 22],
        [24, 26]],

       [[36, 38],
        [40, 42]],

       [[52, 54],
        [56, 58]]])
```

四维数组一共有4个轴，至此我们已经把最外层的两个轴（0、1）计算完了，还剩下4-2=2个轴，这两个轴（2,、3）按照我们上面的结论，分别对应内层数组的行（轴0）、列（轴1）。对轴2、3进行求和计算实际上就是对这些二维数组的行、列分别进行求和。

以A = [[0,1], [2, 3]]来说，对其0、1轴求和分别等于[2, 4]、[1, 5]，同理可求出剩余的二维数组的相关值，因此对原四维数组轴2、3求和的结果为：

```python
>>> arr2.sum(axis=2)
array([[[ 2,  4],
        [10, 12]],

       [[18, 20],
        [26, 28]],

       [[34, 36],
        [42, 44]],

       [[50, 52],
        [58, 60]]])
>>> arr2.sum(axis=3)
array([[[ 1,  5],
        [ 9, 13]],

       [[17, 21],
        [25, 29]],

       [[33, 37],
        [41, 45]],

       [[49, 53],
        [57, 61]]])
```

这就证明了我们上面的结论是完全正确的，当维度N≥5N≥5时，原理是一样的，只是稍微繁琐一些。**需要注意的是，如果我们要手算，应该进行降维，降维后的维度最好是2，因为这是我们能直观理解的最佳维度，外层计算完后，计算内层时，内层元素进行维度还原时，也最好是二维数组**。

###### 2、维度

   numpy数组中的维度(dimension)官方定义说是指轴的个数，通俗点讲，就是你要取得这个数组里面的某个元素必须使用的索引的个数，比如有如下数组：

```
arr1 = np.array([[1,2], [7,5]])
```

   我们要使用**`arr1[1][0]`**来取得数组中的元素**`7`**，即用了两个索引来获得数组元素，因此数组**`arr1`**的维度即为**2**。

###### 3、秩

  官方定义中，秩即为轴的个数。

##### [2、本文来源地址](https://flat2010.github.io/2017/05/31/Numpy%E6%95%B0%E7%BB%84%E8%A7%A3%E6%83%91/)

##### 3、另外推荐：图解NumPy可视化指南

[Web链接：**图解NumPy可视化指南**](https://www.yanxishe.com/TextTranslation/3198)

[本地文件链接：图解NumPy可视化指南.pdf](./图解NumPy可视化指南.pdf)

