

# 第4章 数据组织——数组

 

[toc]

 

## 4.1 一维数组

 

### 4.1.1 一维数组定义

 

由于const定义的常量具有变量的性质，因此这类常量不能作为定义数组的“长度表达式”。

 

### 4.1.2 一维数组初始化

 

- 对于局部数组，若没有进行初始化，其所有元素值为垃圾值；若初始化时仅对部分元素赋了初值，其余元素取默认值（数值型为0，字符型为空字符）

 

- 除了初始化外，数组名不能作为左值，因为它是一个表示首元素地址的常量

 

- 数组名具有地址概念，是代表**数组** **首元素**的**地址常量**，因此可以将数组名赋给指针，例如`int a[10]`中`a`与`&a[0]`含义相同，“`a==&a[0]`”返回真

 

- `&a`表示**整个数组**的首地址，其与`a`的区别主要是**步长的不同**。`a+i=a+i*sizeof(int)`，其步长为`sizeof(int)`；而`&a+i=&a+i*(a数组的大小)`（这里为`10*sizeof(int)`）.因此尽管二者值相同，但表示不同的含义。因此`&a==a`是错误的比较，因为它们的数据类型并不相同（一个是`int *[10]`，一个是`int *`）

 

- 归纳起来，`int a[10],*p=a;`情况下：

 

  - `p+i`和`a+i`就是`a[i]`的地址，地址值都要进行`a+i*d`（d为步长）的运算

  - `*(p+i)`或`*(a+i)`就是`p+i`或`a+i`所指向的数组元素`a[i]`。数组元素中的“[]”是变址运算符，相当于`*(+)`，`a[i]`相当于`*(a+i)`

  - 指向数组元素的指针变量也可以带下标，所以`a[i]`、`*(a+i)`、`p[i]`、`*(p+i)`全部等价

  - 注意p和a的差别，p是指针变量，a是符号常量，a不能作为左值

 

- `*p++` 、`*++p`、 `(*p)++`、`++(*p)`区别

 

  - `*p++`

    解析：等同于`*p;  p += 1;`由于`*`和`++`的运算优先级一样，且是右结合。故`*p++`相当于`*(p++)`，p先与++结合，然后p++整体再与`*`结合。**前面陈述是一种最常见的错误**。因为++后置的时候，本身含义就是先运算后增加1（运算指的是p++作为一个整体与前面的`*`进行运算；增加1指的是p+1），所以**实际上`\*p++`符号整体对外表现的值是`\*p`的值，运算完成后p再加**1.

    【注意】是运算后p再加1，而不是p所指向的变量`*p`再加1

  - `*++p`

    解析：等同于 `p += 1; *p;`由于++在p的前面，++前置的含义是，先加1，得到一个新的p（它的值是原来p的值加1）。然后这个新的p再与前面的`*`结合.

 

  【总结】无论是`*p++`还是`*++p`，都是指针`p += 1`，即p的值+1，而不是p所指向的变量`*p`的值+1。++前置与++后置，只是决定了到底是先`p+=1`，还是先`*p`。++前置表示先`p+= 1`，再`*p`。++后置表示先`*p`，在`p+= 1`

 

  - `(*p)++`

    解析：使用()强制将`*`与p结合，只能先计算`*p`，然后复制创建`*p`副本，再对原始`*p`整体的值++，最后结果返回复制创建的`*p`副本值，因此其结果不能作为左值。

  - `++(*p)`

    解析：先`*p`取值，再前置++，该值+1后作为整个表达式的值。

 

### 4.1.3 一维数组和指针的差异

 

例如：`char *p="abc"; char s[]="abc";`

 

- 对于字符串"abc"，编译器存储的是常量"abc\0"

- 对于`char *p="abc";`

  - 定义的是一个字符指针p，没有动态分配空间来存放字符串，所以编译器把"abc"当作常量存放在静态数据区，p作为指针指向这个常量的地址。因此，最好采用`const char *p="abc";`的定义方式；

  - 该定义中，因为字符串是常量，因此不能通过指针p来修改"abc".

  - 如果希望p为**指针变量**，又要初始化"abc"，定义方式应为：

    `char *p=(char*)malloc(4sizeof(char));strcpy(p;"abc");`

  - `sizeof(p)`值为4，含义表示一个地址空间的大小

- 对于`char s[]="abc";`

  - 定义的是一个字符数组，编译器把它解析为 `char s[4]={'a','b','c','\0'};`

  - 如果数组s是已初始化的全局数组或者静态局部数组，则存放在静态数据区，如果是在函数内部定义的局部数组则存放到栈空间

  - `sizeof(s)`值为4，含义表示数组s含有4个字符元素（含结尾符）

 

### 4.1.4 运算符sizeof

 

- sizeof的三种语法格式

 

  - sizeof (object)

  - sizeof (type_name)

  - sizeof object

 

- 基本数据类型的sizeof：大小一般与系统相关

 

- 指针变量的sizeof：等于计算机内部地址总线的宽度

 

- 数组名的sizeof：等于其元素类型做sizeof的结果乘以数组元素的个数，即返回整个数组在内存中占用的内存字节数

 

- [数组名在作为函数参数传递过程中，会退化成指针，因此在函数内部使用数组名的sizeof时，返回退化为指针变量的sizeof，而非返回原数组名的sizeof.](https://blog.csdn.net/KangRoger/article/details/20653255)

 

- sizeof的副作用

 

  > sizeof(i++)之后，i的值会怎样？答案是不变。记得大一初学C语言时想研究一下sizeof与函数有什么区别，得到的结果只是一些语法上的差别；学了汇编之后看看编译器生成的代码，才发现sizeof在编译时直接给定了一个常值，而非在运行时求值。进而又分析过sizeof(表达式)的结果，清楚了类型提升原理。但我之前没有注意过表达式中出现副作用的问题，于是在sizeof(i++)的问题上犹豫了。现在经过查阅资料和实验，结论是：sizeof在大多数情况下是编译时定值的，表达式中的任何副作用（包括有副作用的运算符、函数调用等）都不会发生。这里说“大多数情况”，排除了针对C99的新特性——不定长数组（variable length array）的特例。

  > [原文出处点击此处](https://linjian.org/blog/tech/programming/c/sizeof-problems)

 

 

 

## 4.2 二维数组

 

### 4.2.1 二维数组的定义

 

- `数据类型 数组名[长度表达式1][长度表达式2]；`

  长度表达式1 指数组行大小，长度表达式2 指数组列大小，都必须为正整数

  二维数组中的所有元素在内存中按行序优先存放，即先顺序存放第1行的元素，再存放第2行的元素，以此类推。

 

### 4.2.2 多维数组的各级地址

 

- 以二维数组为例， 设二维数组 a 有3行4列，定义：`int a [3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};`

  - 其中， a 是数组名，它的各元素是按行顺序存储的。a 数组有3 行，将它们看成3 个一维数

    组元素，即`a={a[O],a[1],a[2]} `，每个一维数组元素又含4 个元素。这种降维的思路可以扩

    展到三维或三维以上的数组。

  - **数组名 a 代表的是该二维数组首元素 a[0] 的首地址**，即a 与＆a[0] 的含义相同，

    `a==&a[0]`返回真，是正确的比较。因此，二维数组名是个二级地址（例如，`**a` 的结果为

    `a[0][0]` ），三维数组名是个三级地址，以此类推。

  - 二维数组 a 的一维数组元素`a[i] (0≤i≤2)`又是一级地址，例如， `a[0]`与`&a[0][0] `的含

    义相同(`&a[0][0] `中的＆运算符将其提升为一级地址）， `a[0]==&a[0][0]` 返回真，是正确的

    比较。

  - &a 是**整个二维数组的首地址**，为三级指针，所以`a==&a` 的比较是错误的，会出现

    `'==': no conversion from 'int (＊)[3][4]' to 'int (*)[4]' `的编译错误。

- **总结**：

  - 对于一维数组b, `b[j] `相当千`＊(b+j)`

  - 对千二维数组元素`a[i][j]` ，将一维数组元素`a[i] `当成 b 代入`＊(b+j)`得到`＊(a[i]+j) `，再将

    其中的`a[i]` 换成`＊(a+i)`又得到`＊(＊(a+i)+j) `，所以`a[i][j] `、 `＊(a[i]+j) `、 `＊(＊(a+i)+j)`三者相同都表示第 i 行第 j 列元素。

 

| 表达式                                  | 含义                                                         |

| :-------------------------------------- | :----------------------------------------------------------- |

| a、&a[0]                                | 分别为二维数组名和首元素a[0]的地址，两者含义相同，均为**二级地址**。 |

| a[0] 、`＊(a+O) `、＊a 、`&a[0][0]`     | 均为`a[0][0]`元素的地址，四者含义相同，均为一级地址          |

| `a[0]+1` 、`*a+1` 、`&a[0][1]`          | 均为`a[0][1]`元素的地址， 三者含义相同，均为一级地址         |

| a+1、`&a[1]`                            | 均为a[1] 的地址，两者含义相同，均为二级地址                  |

| a[1] 、`*(a+1)` 、`&a[1][0]`            | 均为`a[1][0]`元素的地址， 三者含义相同，均为一级地址         |

| a[1]+3 、`*(a+1)+3 `、`&a[1][3]`        | 均为`a[1][3]`元素的地址， 三者含义相同，均为一级地址         |

| `*(a[1]+3)` 、`*(*(a+1)+3)` 、`a[1][3]` | 均为`a[1][3] `元素， 三者含义相同                            |

 

（注意：二级地址与二级指针并非一个概念）

 

 

 

## 4.3 字符数组和字符串数组

 

 

 

### 4.3.1 字符数组

 

- 定义及初始化

  - 字符数组中的元素是字符，因此在对字符数组中的元素赋值时必须使用单引号

  - 初始化表中的初值个数可以少于数组元素的个数，这时只为数组的前几个元素赋初值，其余的元素将自动被赋以**空格符**（空格符不同于空字符，空字符的ASCII 码为0, 空格符的ASCII码为32)。如果初始化表中的初值个数多于数组元素的个数，则被当成语法错误来处理

- sizeof 运算符与strlen函数的差别：

  - strlen 函数用于**求一个字符串的实际长度**，从开始字符到遇见第1个'\0'，如果只定义没有给它赋初值，这个结果是不定的，它会从首地址一直找下去，直到遇到 '\0' 停止

  - sizeof 运算符**返回变量定义后所占内存的字节数**，不是实际长度。例如，定义char a[5], strlen(a)的结果是不定的，因为数组a没有赋初值，而sizeof(a)的结果为5

  - sizeof 可以用类型作为参数，而strlen 只能用char ＊作为参数，且必须是以“\0”结尾的

  - 数组在作为strlen 的参数时退化为指针，而作为sizeof 的参数时不退化

  - strlen 的结果要在执行时才能计算出来，是用来计算字符串的长度，不是类型占内存的大小；而sizeof 不能返回动态分配的空间大小

 

### 4.3.2 字符串数组

 

- 字符串数组的赋值操作

 

  - 初始化赋值，如：`char name[3][8]={ "Mary","Smith","GoodBye" };`

  - 使用scanf 或者gets 函数赋值，如：

 

  ```c

  scanf("%s",name[0]) ; ／／输入的字符串不能含空格

  gets(name[0]) ;       ／／输入的字符串可以含空格

  ```

 

  - 使用标准字符串函数strcpy等实现字符串的复制，如：`strcpy(name[0], "Smith");`

  - 使用一般赋值语句赋值，如：`name [0][0]='M'; name [0][1] ='a';etc...` 注：在这种情况下，编译器不会自动添加结尾符 '\0', 需要程序添加

 

 

 

## 4.4 指针数组

 

 

 

- 当多个基类型相同的指针变量集合成数组时，就形成了指针数组。指针数组是**指针的集合**，它的每个元素都是一个指针变量。其定义形式为：`数据类型 ＊指针数组名［长度表达式］；`

 

- 实例解析：`int *p[3];`

 

  由千`[]`比`*`优先级高，因此p先与[3]结合，形成p[3] 的数组形式，它有3个元素。然后再与p前面的`*`结合，表示是**指针类型的数组**，该数组的每个元素都是整型数的指针，所以每个元素都具有指针的特性。

 

 

 

## 4.5 数组指针

 

 

 

因为数组名是常量，不能像变量那样操作，为此可以设计指向数组的指针变量，以便于数组的操作。

 

- 一维数组指针，例如`int a[]={l,2,3},*p=a; `，通过指针p 访问数组a 的元素，其中a 为一级地址，p 为一级指针。

 

- 二维数组指针，定义格式：`基类型 （＊指针变量）［长度表达式］`，“长度表达式”指出二维数组中列的大小.

 

  - 例如：`int a[2][3] , (*p)[3]=a; `  解析（对比指针数组例子）：

 

    在`(*p)[3] `中，由于括号和［］的优先级相同，其结合性是从左到右的，所以“*“首先与p 结合，表示p是一个指针变量，然后再与［］结合，表示指针变量p的基类型（即这个p指向的变量的类型）是一个包含有3 个int型元素的数组，也就是说p为一个二维数组的指针变量，该数组中每列有3个元素。

 

- 二维数组名不能直接幅给二维指针的原因

 

  - **二维数组名** 指向 一个包含有已知列数量个基础类型元素的数组 的**二级地址常量**，而**二维指针** 是指向 基础类型的指针 的**二维指针变量**；例如：

 

    ```c

    int a[2][3];  int **pa;     pa=a;//p=a会报错

    int a[2][3];  int (*pb)[3]; pb=a;//正确

    int a[2][3];  int **pc;     pc=(int**)a;//正确

    ```

 

    - 因为a指向包含3个int型元素的一维数组，a逻辑上等同于&a[0]，此时a+1是a[1]的地址，所以步长为sizeof(a[0])=4×3=12 ；

 

    - 而pa是指向int *类型的二维指针，步长未知，因此两者指向对象的类型并不相同。而第二行代码中，说明了pb是一个指针变量，且pb这个指针变量指向的是一个包含有3个int型元素的数组，其步长也为12 ；这也解释了**为什么定义二维数组指针时必须要指定列的大小**：因为要“指定”你的二级地址/二维指针的步长。

    -  第三行代码强制转换后语法正确，但不能通过pc 来访问数组a 的元素，因为强制转换之后已经丢失步长信息。

 

  - 一旦定义了二维数组指针变量，该数组指针变量就可以像数组名一样使用，且可以在数组元素中移动.

 

- 三维数组指针

 

  - 定义：`基类型 ( (＊指针变批)[第二维长度] ) [第三维长度];`





